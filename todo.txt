SIGO CON
SIGO CON
SIGO CON

	El datatables que está en la página de Users, ya funciona. El problema es que a cada petición recupera TODOS los registros de la BD. La mejor alternativa es armar yo de cero mi propia integración. Así ya no dependo de nadie más que de mi propio código. Para hacer esto, tengo que lograr que el servidor (en mi controlador) devuelva los registros solicitados según lo que se seleccione en la tabla. Para ello tengo que recuperar todos los parámetros que vienen en la petición y trabajarlos para devolver lo que se espera. Esta es la documentación acerca de los parámetros que vienen en una petición datatables: https://datatables.net/manual/server-side


	Para lograr esto, tengo dos alternativas:

	Si después de intentar esta primera alternativa, sigo sin poder lograrlo, no tiene sentido seguir con la 2da, pues la 2da me dice cómo recuperar los parámetros datatables, cosa que se hace en la 1ra alternativa. Ahora bien, si, repito, después de intentar la 1ra alternativa no puedo lograrlo, entonces quedarme con la integración que ya tengo actualmente en la tabla que lista los users. Ya funciona, sólo hay que armar todo para que sea fácil integrar todos los datatables de todos lados (quizá un solo controlador para esto). Y tener en cuenta que esto funcionará para tablas con número moderado de registros: con 500 funciona sin problema en mi local.

	1. Seguir con el tutorial de https://tutorial101.blogspot.com/2021/04/datatable-ajax-pagination-using-python.html?m=1 AJAJajajaja, de hecho aquí está el código que necesito:
		@app.route("/ajaxfile",methods=["POST","GET"])
		def ajaxfile():
			conn = mysql.connect()
			cursor = conn.cursor(pymysql.cursors.DictCursor)

			if request.method == 'POST':
				draw = request.form['draw']
				row = int(request.form['start'])
				rowperpage = int(request.form['length'])
				searchValue = request.form["search[value]"]

				## Total number of records without filtering
				cursor.execute("select count(*) as allcount from employee")
				rsallcount = cursor.fetchone()
				totalRecords = rsallcount['allcount']

				## Total number of records with filtering
				likeString = "%" + searchValue +"%"
				cursor.execute("SELECT count(*) as allcount from employee WHERE name LIKE %s OR position LIKE %s OR office LIKE %s", (likeString, likeString, likeString))
				rsallcount = cursor.fetchone()
				totalRecordwithFilter = rsallcount['allcount']

				## Fetch records
				if searchValue=='':
					cursor.execute("SELECT * FROM employee ORDER BY name asc limit %s, %s;", (row, rowperpage))
					employeelist = cursor.fetchall()
				else:
					cursor.execute("SELECT * FROM employee WHERE name LIKE %s OR position LIKE %s OR office LIKE %s limit %s, %s;", (likeString, likeString, likeString, row, rowperpage))
					employeelist = cursor.fetchall()

				data = []
				for row in employeelist:
					data.append({
						'name': row['name'],
						'position': row['position'],
						'age': row['age'],
						'salary': row['salary'],
						'office': row['office'],
					})

				response = {
					'draw': draw,
					'iTotalRecords': totalRecords,
					'iTotalDisplayRecords': totalRecordwithFilter,
					'aaData': data,
				}

				return jsonify(response)

	2. En este video https://www.youtube.com/watch?v=cDlo4v2LKmQ&t=1318s se hace justo lo que necesito: leer cada parámetro enviado en la petición datatables y devolver una respuesta de acuerdo a dichos parámetros. Todo esto se hace en un CodeIgniter. Una vez que ya haya armado ese Codeigniter, ahora sí regresar a Python e intentar replicarlo en Python. Sólo recordar que para devolver un jSON en Python, hay que hacerlo con:
		import json
		json.dumps(resultado)






			1. El login ya se arma con MySQL, también los posts mostrados en el blog del frontend. Pero quedan muchos lugares que aún llaman a SQLite. Cambiar todo a MySQL.
			2. Probar si funciona poner una carpeta templates en los blueprints. Si no funciona, no importa porque ahora todas las vistas están bien ordenadas en la carpeta /templates
			3. Asegurarme que funcionen las vistas de errores
			4. Implementar el paquete Flask-Login
				https://www.digitalocean.com/community/tutorials/how-to-add-authentication-to-your-app-with-flask-login-es
			5. Migraciones
			6. Poner slug a los blogposts
			7. Si un nuevo post viene con un slug ya existente, al final del slug se agregue: -2

